---
title: Конфиг проекта
---

# Конфиг проекта для Собираки

_Конфиг проекта_ — файл в формате YAML, который определяет все настройки [проекта](../11-overview/01-terms.md).

Все пути в конфиге ([`paths.root`](#paths.root), [`web.theme`](#web.theme) и т.п.) указываются относительно директории, в которой он находится.

::: note
Если ваш текстовый редактор поддерживает работу с JSON Schema, вы можете подключить схему из файла `sobiraka-project.yaml`, чтобы комфортнее редактировать конфиг вашего проекта.
:::

## Общая структура и примеры {#examples}

Общая структура конфига может выглядеть по-разному в зависимости от сложности проекта, который он описывает.

### Два языка, два тома {#example-2v-2l}

Данный пример описывает проект, содержащий два языка (`en` и `ru`) и два тома (`admin-manual` и `user-manual`). Каждая языковая версия каждого тома имеет собственные настройки [`title`](#title) и [`paths.root`](#paths.root).

```yaml
primary: admin-manual
languages:
  en:
    volumes:
      admin-manual:
        title: Admin manual
        paths:
          root: src/en/admin-manual
      user-manual:
        title: User manual
        paths:
          root: src/en/user-manual
  ru:
    volumes:
      admin-manual:
        title: Руководство администратора
        paths:
          root: src/ru/admin-manual
      user-manual:
        title: Руководство пользователя
        paths:
          root: src/ru/user-manual
```

### Два языка, один том {#example-2v-1l}

Данный пример описывает проект из одного тома, представленного на двух языках (`en` и `ru`). В отличие от примера [«Два языка, два тома»](#example-2v-2l), здесь не используется конструкция `volumes`: вместо этого ключам `en` и `ru` соответствуют непосредственно настройки тома.

```yaml
primary: ru
languages:
  en:
    title: Manual
    paths:
      root: src/en
  ru:
    title: Руководство
    paths:
      root: src/ru
```

### Один язык, два тома {#example-1v-2l}

Данный пример описывает проект, содержащий два тома (`admin-manual` и `user-manual`) на одном языке. В отличие от примера [«Два языка, два тома»](#example-2v-2l), здесь опускается конструкция `languages`, а конструкция `volumes` вынесена на верхний уровень.

```yaml
primary: admin-manual
volumes:
  admin-manual:
    title: Admin manual
    paths:
      root: src/admin-manual
  user-manual:
    title: User manual
    paths:
      root: src/user-manual
```

### Один язык, один том {#example-1v-1l}

Данный пример описывает проект из одного тома на одном языке. Конструкции `languages` и `volumes` опускаются.

```yaml
title: Admin manual
paths:
  root: src/admin-manual
```

### DEFAULT-конфигурации и переменные {#default}

Внутри объектов `languages` и `volumes` могут присутствовать специальные псевдоязыки или псевдотома с кодовым именем `DEFAULT`. Они позволяют определить значения по умолчанию для других языков и томов, избежав ненужного дублирования в конфигурационном файле.

В большинстве значений внутри `DEFAULT` могут использоваться переменные, зависящие от языка и тома, куда значения подставляются:

- `$LANG` — язык текста;
- `$VOLUME` — кодовое имя тома;
- `$AUTOPREFIX` — [идентификатор тома](../11-overview/01-terms.md#volume) (в общем случае то же, что `$LANG/$VOLUME`).

Например, конфигурация ниже полностью идентична конфигурации из раздела [](#example-1v-2l), но использует переменную `$VOLUME`, чтобы сформировать нужный путь `root` для каждого тома.

```yaml
primary: admin-manual
volumes:
  DEFAULT:
    paths:
      root: src/$VOLUME

  admin-manual:
    title: Admin manual
  user-manual:
    title: User manual
```

## Глобальные свойства {#global-configuration}

### `primary_language`

Язык, который используется в качестве первоисточника при переводе томов, см. [Мультиязычность](../11-overview/03-multilang.md).

Если настройка не задана, то используется первый язык в порядке объявления в конфиге.

## Основные настройки тома {#volume-configuration}

### `title`

Заголовок документа. При сборке [HTML](../21-build-html/) используется при формировании заголовков страниц, а при сборке [PDF](../22-build-pdf/) используется в качестве имени выходного файла по умолчанию.

### `variables`

Словарь с дополнительными переменными. Эти переменные можно использовать внутри страниц с помощью [синтаксиса Jinja](../12-syntax/2-jinja.md), например: `{{ '{{ MYVAR }}' }}`.

Также переменные можно использовать в [оформлении LaTeX](../22-build-pdf/4-latex-customization.md), например: `\MYVAR`. Подобные команды создаются для переменных, в именах которых содержатся только латинские символы и символ подчёркивания. Например, переменная с именем `MyVar1` не будет передана в LaTeX.

Пример дополнительных переменных:

```yaml
variables:
  PRODUCT: Sobiraka
  PYTHON_VERSION: 3.11
  YEAR: 2024
```

## Пути к файлам {#paths}

### `paths.root`

Директория, в которой находятся исходные текстовые файлы. Если не указана, то будет использоваться директория, в которой находится конфиг.

### `paths.include`

Список из одного или нескольких шаблонов для включения текстовых файлов в том.

Использование этой настройки позволяет избежать нежелательных эффектов, если вы используете один и тот же корень для нескольких томов или совмещаете корни текстовых файлов и ресурсов. Так, вы можете указать шаблон `**/*_ru.md` для русскоязычного тома и `**/*_en.md` для англоязычного, при этом ни в один из них не попадут файлы, отличные от Markdown.

Для поиска файлов по шаблонам используются функции из библиотеки [`wcmatch`](https://facelessuser.github.io/wcmatch/glob/) с включёнными опциями `GLOBSTAR` и `NODIR`. Если указано несколько шаблонов, то в том попадут файлы, соответствующие хотя бы одному из них (и не соответствующие ни одному из шаблонов [`paths.exclude`](#paths.exclude)). Если настройка не задана, то используется один шаблон `**/*`, которому соответствуют все файлы на любой глубине.

### `paths.exclude`

Список из одного или нескольких шаблонов для исключения текстовых файлов из тома.

Собирака использует эти шаблоны после [`paths.include`](#paths.include), чтобы удалить лишнее из списка найденных файлов.

Для поиска файлов по шаблонам используются функции из библиотеки [`wcmatch`](https://facelessuser.github.io/wcmatch/glob/) с включёнными опциями `GLOBSTAR` и `NODIR`. Если указано несколько шаблонов, то из тома будут исключены файлы, соответствующие хотя бы одному из них. Если настройка не задана, то никакие файлы не будут исключены.

### `paths.resources`

Директория, в которой находятся изображения, видео и прочие ресурсы для документации.

### `paths.partials`

Директория, файлы из которой можно будет включать в другие файлы, см. [](../12-syntax/2-jinja.md#includes).

### `paths.naming_scheme`

Список регулярных выражений для парсинга имён исходных файлов. Все выражения должны быть совместимы со стандартной функцией [`re.fullmatch()`](https://docs.python.org/3/library/re.html#re.fullmatch) при включённом флаге [`re.VERBOSE`](https://docs.python.org/3/library/re.html#re.X).

При анализе исходного файла или директории с исходными файлами Собирака перебирает регулярные выражения в указанном порядке и проверяет, соответствует ли им имя файла. Когда подходящее выражение найдено, перебор прекращается, а из результата проверки извлекаются (при наличии) именованные группы `is_main`, `pos` и `stem`.

- Если группа `is_main` не пуста, то файл считается индексным для своей директории и всегда отображается в ней первым.

- Если группа `pos` не пуста, то её содержимое интерпретируется как целое число. Файлы и поддиректории внутри одной директории сортируются по возрастанию `pos`. Файлы и поддиректории с пустой группой `pos` помещаются в конец списка.

- Если группа `stem` не пуста, то её содержимое используется в качестве имени выходного файла или директории при [сборке HTML](../21-build-html/1-web.md). Если группа пуста, то вместо этого используется всё имя файла без расширения.

Регулярные выражения по умолчанию составлены таким образом, чтобы поддерживать форматы файлов вида `⟨pos⟩-⟨stem⟩.⟨тип⟩`, `⟨pos⟩.⟨тип⟩` и `⟨stem⟩.⟨тип⟩`. Индексными в этой схеме считаются файлы с числом “0” вместо группы `pos` или строкой “index” вместо группы `stem`, например: `0.md`, `0-toc.md`, `index.md`.

## Настройки содержимого {#content}

### `content.numeration`

Если `true`, то в начало каждого заголовка в документации будет добавлен его порядковый номер. См. [](../11-overview/02-files.md#autonumeration).

## Настройки WebBuilder {#web}

### `web.toc_depth`

Глубина, до которой должны быть раскрыты неактивные пункты оглавления. Не применяется к активному пункту и всем его родительским пунктам. См. [](../11-overview/02-files.md#toc).

Допустимые значения:

- `infinity` (по умолчанию) — меню будет раскрыто полностью;
- любое целое положительное число — меню будет раскрыто до этого уровня.

### `web.combined_toc`

Эта опция позволяет встраивать локальное оглавление страницы внутрь глобального оглавления. См. [](../11-overview/02-files.md#toc).

Допустимые значения:

- `never` (по умолчанию) — не встраивать локальное оглавление в глобальное;
- `current` — встраивать локальное оглавление текущей страницы;
- `always` — встраивать локальное оглавление каждой страницы.

### `web.prefix`

Путь к поддиректории для выходных HTML-файлов отдельно взятого тома.

Если настройка не задана, она считается равной `$AUTOPREFIX`, что означает автоматическое создание поддиректорий для каждого языка, а внутри — для каждого тома. См. [](#default).

### `web.resources_prefix`

Поддиректория в выходной директории, в которую будут скопированы изображения, видео и прочие ресурсы для документации из директории [`paths.resources`](#paths.resources).

Если настройка не задана, используется директория “_resources”.

### `web.resources_force_copy`

Список файлов, которые следует скопировать из [`paths.resources`](#paths.resources) в [`web.resources_prefix`](#web.resources_prefix) принудительно, даже если на них не ссылается ни одна страница документации. Например, здесь нужно указать путь к логотипу проекта, если используемая тема на него ссылается.

### `web.theme`

Название или путь к директории с HTML-темой.

При чтении этой настройки Собирака сначала пытается найти указанную тему в директории, в которой находится конфиг. Если тема не найдена, поиск продолжается в дистрибутиве самой Собираки, куда входят три темы:

- `simple` — некрасивая тема с минимумом CSS для отладки и прототипирования;
- `material` — тема на основе [Material for Sphinx](https://bashtage.github.io/sphinx-material/).
- `book` — тема на основе [Hugo Book Theme](https://github.com/alex-shpak/hugo-book) (используется в документации, которую вы читаете сейчас).

Если настройка не задана, используется тема `simple`.

Помимо самой темы, в директории также может находиться файл `extension.py`. Если он существует и если в нём определён класс, расширяющий класс `WebProcessor`, то Собирака может использовать его в качестве обработчика по умолчанию, если [`web.processor`](#web.processor) не задан.

### `web.theme_data`

Словарь, который будет в неизменном виде передан шаблонизатору в качестве переменной `theme_data`. Поддержка и ожидаемые ключи и значения в этом словаре зависят от используемой темы.

### `web.processor`

Путь к файлу Python, в котором определён [обработчик страниц](4-processor-api.md) для тома.

Если настройка не задана, используется обработчик из темы (см. [`web.theme`](#web.theme)) или стандартный класс `WebProcessor`.

### `web.highlight`

Настройка подсветки кода в веб-документации. На выбор доступны три библиотеки для подсветки: [highlight.js](https://highlightjs.org/), [Prism](https://prismjs.com/) и [Pygments](https://pygments.org/).

Если вас устроит поведение по умолчанию, просто укажите название, например: `highlight: prism`. Но для более тонкой настройки укажите в `highlight` не строку, а словарь, где единственным ключом будет название библиотеки (`highlightjs`, `prism` или `pygments`), а единственным значением — вложенный словарь с настройками. Например:

```yaml
web:
  highlight:
    prism:
      version: 1.29.0
      location: jsdelivr
      style: solarizedlight
```

Принцип работы подсветки и доступные настройки различаются для разных библиотек.

Библиотеки [highlight.js](https://highlightjs.org/) и [Prism](https://prismjs.com/) реализованы на JavaScript и работают в браузере пользователя. Собирака автоматически подставляет в шапку каждой страницы теги `<script>`, указывающие на все необходимые скрипты: например, для highlight.js это будут скрипт библиотеки плюс плагины для языков кода, использованных в вашем проекте. Можно указать:

- один из популярных хостингов библиотек: `cdnjs`, `jsdelivr` или `unpkg` (в настройке `version` можно указать точную версию библиотеки);
- URL директории на произвольном хостинге (по аналогии с [этой ссылкой на jsDelivr](https://cdn.jsdelivr.net/npm/prismjs@1.29.0/));
- путь к директории в исходниках проекта, начинающийся с `./` (при сборке Собирака убедится, что нужные файлы действительно существуют).

Библиотека [Pygments](https://pygments.org/) устроена принципиально иначе: вся работа производится в момент сборки, поэтому для отображения блока кода браузеру не требуется никаких дополнительных ресурсов (не считая CSS-стиля, о котором см. ниже). На данный момент это единственная библиотека из поддерживаемых Собиракой, которая может работать и при сборке HTML, и при сборке PDF — поскольку JavaScript при сборке PDF не выполняется. Поэтому Pygments имеет смысл использовать в проектах, где важно обеспечить максимально близкий визуальный стиль документации в обоих форматах. Описание дополнительных настроек для Pygments аналогично настройкам, описанным для [`pdf.highlight`](#pdf.highlight).

Для каждой библиотеки можно указать настройку `style`, чтобы Собирака подключила выбранный CSS-стиль подсветки. Для каждой библиотеки доступен её собственный стандартный набор стилей. Если указать значение `null`, то Собирака будет считать, что вы уже позаботились о CSS в вашей теме, и никакие стили дополнительно подключать не будет.

### `web.custom_scripts`

Список путей к скриптам JS, используемым в оформлении документации.

### `web.custom_styles`

Список путей к стилям CSS или SASS, используемым в оформлении документации.

## Настройки поиска {#web.search}

### `web.search.engine`

Движок для [поиска по документации](../11-overview/04-search.md). На данный момент поддерживается только одно значение: `pagefind`.

Если настройка не задана, поиск будет выключен.

### `web.search.generate_js`

Если настройка включена, то Собирака автоматически добавит скрипт, инициализирующий [Pagefind UI](https://pagefind.app/docs/ui-usage/) в каждую генерируемую страницу. В противном случае ответственность за добавление скрипта лежит на авторе используемой [HTML-темы](../21-build-html/2-web-customization.md).

### `web.search.container`

CSS-селектор для выбора элемента, внутри которого должен быть инициализирован [Pagefind UI](https://pagefind.app/docs/ui-usage/). Нужное значение зависит от используемой вами темы. По умолчанию используется селектор `search`, то есть Pagefind UI создаётся внутри элемента `<search>` на странице.

### `web.search.index_path`

Поддиректория в выходной директории, в которую будут сохранены все скрипты, стили и данные для работы поиска.

Если настройка не задана, используется поддиректория `_pagefind`.

### `web.search.skip_elements`

Список типов элементов, содержимое которых должно игнорироваться при индексации. Допустимые значения — названия классов элементов из [Panflute API](https://scorreia.com/software/panflute/code.html).

Пример:

```yaml
web:
  search:
    skip_elements: [ CodeBlock, Image ]
```

### `web.search.link_target`

Самый мелкий уровень заголовков, на которые может вести ссылка из результатов поиска. Например, если выбрано значение `h2`, то тексты под заголовками третьего и более уровней не будут попадать в поиск отдельно, а будут добавлены к содержимому предыдущего заголовка второго уровня.

Допустимые значения: `h1`, `h2`, `h3`, `h4`, `h5`, `h6`.

Если настройка не задана, используется значение `h1`, то есть в результаты поиска попадают только страницы целиком.

### `web.search.translations`

Строки для локализации стандартного интерфейса Pagefind.

Эта настройка должна быть словарём, ключи в котором должны соответствовать ключам из [файла переводов Pagefind](https://github.com/CloudCannon/pagefind/blob/main/pagefind_ui/translations/en.json). Например:

```yaml
web:
  theme: book
  search:
    engine: pagefind
    translations:
      placeholder: Поиск
      load_more: Показать ещё
      zero_results: Ничего не найдено
```

Если настройка не задана, Pagefind будет использовать все строки по умолчанию.

## Настройки WeasyPrintBuilder {#pdf}

### `pdf.theme`

Название или путь к директории с WeasyPrint-темой. См. [](../22-build-pdf/2-weasyprint-customization.md).

При чтении этой настройки Собирака сначала пытается найти указанную тему в директории, в которой находится конфиг. Если тема не найдена, поиск продолжается в дистрибутиве самой Собираки.

Из тем, входящих в дистрибутив Собираки, только тема `sobiraka2025` в данный момент поддерживает сборку через WeasyPrint.

Если настройка не задана, используется тема `sobiraka2025`.

Помимо самой темы, в директории также может находиться файл `extension.py`. Если он существует и если в нём определён класс, расширяющий класс `WeasyPrintProcessor`, то Собирака может использовать его в качестве обработчика по умолчанию, если [`pdf.processor`](#pdf.processor) не задан.

### `pdf.processor`

Путь к файлу Python, в котором определён [обработчик страниц](4-processor-api.md) для тома.

Если настройка не задана, используется обработчик из темы (см. [`pdf.theme`](#pdf.theme)) или стандартный класс `WeasyPrintProcessor`.

### `pdf.custom_styles`

Список путей к стилям CSS или SASS, используемым в оформлении документации.

### `pdf.toc_depth`

Глубина, до которой должны быть раскрыты пункты оглавления.

Допустимые значения:

- `infinity` (по умолчанию) — меню будет раскрыто полностью;
- любое целое положительное число — меню будет раскрыто до этого уровня.

### `pdf.combined_toc`

Если `true`, то внутрь глобального оглавления будут встроены локальные оглавления страниц. См. [](../11-overview/02-files.md#toc).

### `pdf.headers_policy`

Политика выбора тегов для заголовков в конечном документе (`<h1>`, `<h2>` и так далее).

На выбор доступны две политики.

- `local` (по умолчанию)

  Собирака никак не преобразует теги заголовков, оставляя их на тех же уровнях, на каких они написаны в исходном коде. Например, заголовок `###` в Markdown всегда будет заголовком H3 в конечном документе.

   Эта политика похожа на стандартное поведение веб-документации: на каком бы уровне оглавления ни находилась текущая страница, она начинается с заголовка H1. Это относится и к заголовку корневой страницы: например, вы можете начать её с заголовка `# Введение`, который отобразится как H1.

- `global`

   Собирака вычисляет _глобальный уровень заголовка_ и выбирает тег в соответствии с ним. Это означает, что каждая страница будет строго на один уровень ниже родительской, и подзаголовки будут снижены на соответствующее количество уровней. Например, на странице 4-го уровня заголовок `#` превратится в H4, а заголовок `##` в H5.

   Заголовок `#` на самой первой (корневой) странице не попадает в конечный документ. Заголовками H1 становятся заголовки `##` с корневой страницы, а также заголовки `#` со страниц одним уровне ниже. 

   Эта политика подходит для документов со строго выраженной иерархией. Также она хорошо сочетается с [автонумерацией](../11-overview/02-files.md#autonumeration): заголовки с одной и той же глубиной номера будут выглядеть одинаково.

### `pdf.highlight`

Настройка подсветки кода в PDF-документации. В данный момент поддерживается только одна библиотека для подсветки: [Pygments](https://pygments.org/).

Если вас устроит поведение по умолчанию, просто подключите библиотеку, написав `highlight: prism`. Но для более тонкой настройки укажите в `highlight` не строку, а словарь, где единственным ключом будет `pygments`, а единственным значением — вложенный словарь с настройками. Например:

```yaml
pdf:
  highlight:
    style: bw
    pre_class: pygments
    code_class: highlight
```

Поддерживаемые настройки:

- `style` — стиль подсветки. Должен быть либо строкой с названием одного из [стандартных стилей Pygments](https://pygments.org/styles/), либо значением `null`. В последнем случае Собирака будет считать, что вы уже позаботились о CSS в вашей теме, и никакие стили дополнительно подключать не будет.
- `pre_class` — название класса, которые следует поставить элементу `<pre>`.
- `code_class` — название класса, которые следует поставить элементу `<code>`.

## Настройки LatexBuilder {#latex}

### `latex.header`

Путь к файлу, содержимое которого будет включено в начало генерируемого LaTeX-кода. См. [](../22-build-pdf/4-latex-customization.md).

### `latex.headers_transform`

Правила выбора команд LaTeX для заголовков в документе.

Если настройка не задана, то Собирака вычисляет _глобальный уровень заголовка_ и выбирает команду в соответствии с ним. Это означает, что каждая страница будет строго на один уровень ниже родительской, и подзаголовки будут снижены на соответствующее количество уровней. Например, на странице 4-го уровня заголовок H1 будет иметь уровень 4, а заголовок H2 будет иметь уровень 5. По умолчанию им соответствуют команды `\subsubsection*` и `\paragraph*`. (Звёздочки в конце команд означают, что для заголовков не будет использоваться нативная нумерация в LaTeX. Это никак не влияет на настройку [`content.numeration`](#content.numeration)). С помощью настройки можно заменить эти команды на другие — например, на такие же, но без звёздочек.

Если настройка задана, то она должна содержать одно или более свойств-правил для выбора заголовков. Собирака ищет правила в словарях в следующем порядке. Для каждого заголовка срабатывает первое найденное правило.

1. `by_class` — словарь для выбора команды по имени класса, добавленному к заголовку. Например, если к заголовку добавлена конструкция `{.bigpart}` (в синтаксисе Markdown), то Собирака проверит наличие настройки `latex.headers_transform.by_class.bigpart`.

1. `by_global_level` — словарь для выбора команды по глобальному уровню заголовка. Логика работы совпадает с логикой по умолчанию, описанной выше. Например, при обработке заголовка H2 на странице 4-го уровня Собирака проверит наличие настройки `latex.headers_transform.by_global_level.5`.

1. `by_page_level` — словарь для выбора команды по уровню страницы. Логика применяется только к заголовкам первого уровня. Например, при обработке заголовка H1 на странице 4-го уровня Собирака проверит наличие настройки `latex.headers_transform.by_page_level.4`.

1. `by_element` — словарь для выбора команды по уровню заголовка на странице. Допустимые ключи: `h1`, `h2`, и так далее. Например, при обработке заголовка H3 на любой странице Собирака проверит наличие настройки `latex.headers_transform.by_element.h3`.

Из-за особенностей синтаксиса YAML числовые ключи необходимо заключать в кавычки — например, писать `'1'` вместо `1`.

В примере ниже показана конфигурация, при которой каждая страница проекта, независимо от уровня, будет оформлена командой `\section*`, а страницы с добавленной конструкцией `{.bigpart}` будут оформлены командой `\part*`.

```yaml
latex:
  headers_transform:
    by_class:
      bigpart: part*
    by_element:
      h1: section*
      h2: subsection*
      h3: subsubsection*
```

### `latex.paths`

Словарь с относительными путями, каждый из которых будет превращён в относительный и передан в LaTeX в качестве переменной. См. [](../22-build-pdf/4-latex-customization.md).

### `latex.theme`

Название или путь к директории с LaTeX-темой. См. [](../22-build-pdf/4-latex-customization.md).

При чтении этой настройки Собирака сначала пытается найти указанную тему в директории, в которой находится конфиг. Если тема не найдена, поиск продолжается в дистрибутиве самой Собираки.

Из тем, входящих в дистрибутив Собираки, только тема `simple` в данный момент поддерживает кастомизацию LaTeX.

Если настройка не задана, используется тема `simple`.

Помимо самой темы, в директории также может находиться файл `extension.py`. Если он существует и если в нём определён класс, расширяющий класс `LatexProcessor`, то Собирака может использовать его в качестве обработчика по умолчанию, если [`latex.processor`](#latex.processor) не задан.

### `latex.processor`

Путь к файлу Python, в котором определён [обработчик страниц](4-processor-api.md) для тома.

Если настройка не задана, используется обработчик из темы (см. [`latex.theme`](#latex.theme)) или стандартный класс `LatexProcessor`.

### `latex.toc`

Если `true` (по умолчанию), то в PDF будет включено оглавление, автоматически сгенерированное при помощи LaTeX.

## Настройки автоматических проверок {#prover}

### `prover.dictionaries`

Список словарей, которые будут использоваться для [проверки орфографии](../11-overview/05-prover.md#spell-check).

Допустимые элементы списка:

- `english` — словарь английского языка [с сайта aspell](http://app.aspell.net/create),
- `russian` — словарь русского языка [из репозитория LibreOffice](https://github.com/LibreOffice/dictionaries/tree/master/ru_RU),
- пути к произвольным файлам `*.dic`, `*.txt` или `*.regexp`.

### `prover.skip_elements`

Список типов элементов, содержимое которых должно игнорироваться при [проверках текста](../11-overview/05-prover.md). Допустимые значения — названия классов элементов из [Panflute API](https://scorreia.com/software/panflute/code.html).

Пример:

```yaml
prover:
  skip_elements: [ CodeBlock, Image ]
```

### `prover.phrases_must_begin_with_capitals`

Если `true`, то будет включена [проверка заглавных букв в начале фраз](../11-overview/05-prover.md#phrases-must-begin-with-capitals).

### `prover.allowed_quotation_marks`

Допустимые начертания кавычек для [проверки кавычек и апострофов](../11-overview/05-prover.md#quotation-marks-and-apostrophes).

Настройка задаётся как массив, каждый из элементов которого является ещё одним массивом. Эти массивы обозначают последовательности кавычек, которые можно вкладывать друг в друга. Если настройка пуста (по умолчанию), то Собирака не проверяет кавычки в тексте.

Ниже показан пример конфигурации для русскоязычного тома документации. Первый массив разрешает использование кавычек `„ “`, а второй разрешает использование комбинации вложенных кавычек `«„ “»` (что автоматически разрешает и кавычки `« »` без вложенности). Все кавычки и комбинации кавычек, кроме упомянутых в конфигурации, будут запрещены. Например, `«такой „текст“»` будет считаться корректным, а `«такой "текст"»` — нет.

```yaml
prover:
  allowed_quotation_marks:
    - [German]
    - [Angled, German]
```

Поддерживаются следующие значения:

- `Angled` — кавычки-ёлочки `« »`,
- `CurvedDouble` — английские двойные кавычки `“ ”`,
- `CurvedSingle` — английские одиночные кавычки `‘ ’`,
- `German` — немецкие кавычки-лапки `„ “`,
- `StraightDouble` — простые двойные кавычки `" "`,
- `StraightSingle` — простые одиночные кавычки `' '`.

### `prover.allowed_apostrophes`

Допустимые начертания апострофов для [проверки кавычек и апострофов](../11-overview/05-prover.md#quotation-marks-and-apostrophes).

Настройка задаётся как массив из одного или двух элементов. Если настройка пуста (по умолчанию), то оба начертания считаются допустимыми.

Поддерживаются следующие значения:

- `Curved`  - типографский апостроф `’`,
- `Straight`  - простой апостроф `'`.

::: warning
Проверка кавычек и апострофов не может работать, если в кавычках и апострофах встречается один и тот же символ.

- Если разрешены кавычки `CurvedSingle`, нужно запретить апостроф `Curved`.
- Если разрешены кавычки `StraightSingle`, нужно запретить апостроф `Straight`.

:::